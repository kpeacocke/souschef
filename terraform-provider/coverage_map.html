
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kpeacocke/terraform-provider-souschef/internal/provider/data_source_assessment.go (91.2%)</option>
				
				<option value="file1">github.com/kpeacocke/terraform-provider-souschef/internal/provider/data_source_cost_estimate.go (91.3%)</option>
				
				<option value="file2">github.com/kpeacocke/terraform-provider-souschef/internal/provider/provider.go (85.7%)</option>
				
				<option value="file3">github.com/kpeacocke/terraform-provider-souschef/internal/provider/resource_batch_migration.go (83.5%)</option>
				
				<option value="file4">github.com/kpeacocke/terraform-provider-souschef/internal/provider/resource_habitat_migration.go (78.8%)</option>
				
				<option value="file5">github.com/kpeacocke/terraform-provider-souschef/internal/provider/resource_inspec_migration.go (77.9%)</option>
				
				<option value="file6">github.com/kpeacocke/terraform-provider-souschef/internal/provider/resource_migration.go (84.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package provider implements the SousChef Terraform provider data sources
package provider

import (
        "context"
        "encoding/json"
        "fmt"
        "os/exec"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure the implementation satisfies the expected interfaces
var (
        _ datasource.DataSource              = &amp;assessmentDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;assessmentDataSource{}
)

// NewAssessmentDataSource is a helper function to simplify the provider implementation.
func NewAssessmentDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;assessmentDataSource{}
}</span>

// assessmentDataSource is the data source implementation.
type assessmentDataSource struct {
        client *SousChefClient
}

// assessmentDataSourceModel maps the data source schema data.
type assessmentDataSourceModel struct {
        ID              types.String  `tfsdk:"id"`
        CookbookPath    types.String  `tfsdk:"cookbook_path"`
        Complexity      types.String  `tfsdk:"complexity"`
        RecipeCount     types.Int64   `tfsdk:"recipe_count"`
        ResourceCount   types.Int64   `tfsdk:"resource_count"`
        EstimatedHours  types.Float64 `tfsdk:"estimated_hours"`
        Recommendations types.String  `tfsdk:"recommendations"`
}

// Metadata returns the data source type name.
func (d *assessmentDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_assessment"
}</span>

// Schema defines the schema for the data source.
func (d *assessmentDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                Description: "Fetches migration assessment for a Chef cookbook.",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Description: "Unique identifier (cookbook path).",
                                Computed:    true,
                        },
                        "cookbook_path": schema.StringAttribute{
                                Description: "Path to the Chef cookbook directory.",
                                Required:    true,
                        },
                        "complexity": schema.StringAttribute{
                                Description: "Migration complexity level (Low/Medium/High).",
                                Computed:    true,
                        },
                        "recipe_count": schema.Int64Attribute{
                                Description: "Number of recipes in cookbook.",
                                Computed:    true,
                        },
                        "resource_count": schema.Int64Attribute{
                                Description: "Total Chef resources across all recipes.",
                                Computed:    true,
                        },
                        "estimated_hours": schema.Float64Attribute{
                                Description: "Estimated migration effort in hours.",
                                Computed:    true,
                        },
                        "recommendations": schema.StringAttribute{
                                Description: "Migration recommendations and best practices.",
                                Computed:    true,
                        },
                },
        }
}</span>

// Configure adds the provider configured client to the data source.
func (d *assessmentDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*SousChefClient)

        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *SousChefClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>

        <span class="cov8" title="1">d.client = client</span>
}

// Read refreshes the Terraform state with the latest data.
func (d *assessmentDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var config assessmentDataSourceModel
        diags := req.Config.Get(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cookbookPath := config.CookbookPath.ValueString()

        // Call souschef CLI to assess cookbook
        cmd := exec.CommandContext(ctx, d.client.Path, "assess-cookbook",
                "--cookbook-path", cookbookPath,
                "--format", "json",
        )

        tflog.Debug(ctx, "Executing SousChef assessment", map[string]interface{}{
                "command": cmd.String(),
        })

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Error assessing cookbook",
                        fmt.Sprintf("Could not assess cookbook: %s\n%s", err, string(output)),
                )
                return
        }</span>

        // Parse JSON output
        <span class="cov8" title="1">var assessment struct {
                Complexity      string  `json:"complexity"`
                RecipeCount     int64   `json:"recipe_count"`
                ResourceCount   int64   `json:"resource_count"`
                EstimatedHours  float64 `json:"estimated_hours"`
                Recommendations string  `json:"recommendations"`
        }

        if err := json.Unmarshal(output, &amp;assessment); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error parsing assessment",
                        fmt.Sprintf("Could not parse JSON output: %s", err),
                )
                return
        }</span>

        // Set state
        <span class="cov8" title="1">config.ID = types.StringValue(cookbookPath)
        config.Complexity = types.StringValue(assessment.Complexity)
        config.RecipeCount = types.Int64Value(assessment.RecipeCount)
        config.ResourceCount = types.Int64Value(assessment.ResourceCount)
        config.EstimatedHours = types.Float64Value(assessment.EstimatedHours)
        config.Recommendations = types.StringValue(assessment.Recommendations)

        diags = resp.State.Set(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package provider implements the SousChef Terraform provider data sources
package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces
var (
        _ datasource.DataSource              = &amp;costEstimateDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;costEstimateDataSource{}
)

// NewCostEstimateDataSource creates a new cost estimate data source
func NewCostEstimateDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;costEstimateDataSource{}
}</span>

// costEstimateDataSource is the data source implementation
type costEstimateDataSource struct {
        client *SousChefClient
}

// costEstimateDataSourceModel describes the data source data model
type costEstimateDataSourceModel struct {
        ID                  types.String  `tfsdk:"id"`
        CookbookPath        types.String  `tfsdk:"cookbook_path"`
        Complexity          types.String  `tfsdk:"complexity"`
        RecipeCount         types.Int64   `tfsdk:"recipe_count"`
        ResourceCount       types.Int64   `tfsdk:"resource_count"`
        EstimatedHours      types.Float64 `tfsdk:"estimated_hours"`
        EstimatedCostUSD    types.Float64 `tfsdk:"estimated_cost_usd"`
        DeveloperHourlyRate types.Float64 `tfsdk:"developer_hourly_rate"`
        InfrastructureCost  types.Float64 `tfsdk:"infrastructure_cost"`
        TotalProjectCostUSD types.Float64 `tfsdk:"total_project_cost_usd"`
        Recommendations     types.String  `tfsdk:"recommendations"`
}

// Metadata returns the data source type name
func (d *costEstimateDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_cost_estimate"
}</span>

// Schema defines the schema for the data source
func (d *costEstimateDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Fetches migration cost estimation for a Chef cookbook, suitable for Terraform Cloud cost estimation features.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Unique identifier (cookbook path)",
                        },
                        "cookbook_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the Chef cookbook directory",
                        },
                        "complexity": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Migration complexity level (Low/Medium/High)",
                        },
                        "recipe_count": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Number of recipes in cookbook",
                        },
                        "resource_count": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Total Chef resources across all recipes",
                        },
                        "estimated_hours": schema.Float64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Estimated migration effort in hours",
                        },
                        "estimated_cost_usd": schema.Float64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Estimated labour cost in USD based on developer hourly rate",
                        },
                        "developer_hourly_rate": schema.Float64Attribute{
                                Optional:            true,
                                MarkdownDescription: "Developer hourly rate in USD for cost calculation (default: 150)",
                        },
                        "infrastructure_cost": schema.Float64Attribute{
                                Optional:            true,
                                MarkdownDescription: "Additional infrastructure/tooling cost in USD (default: 500)",
                        },
                        "total_project_cost_usd": schema.Float64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Total estimated project cost including labour and infrastructure",
                        },
                        "recommendations": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Migration recommendations and best practices",
                        },
                },
        }
}</span>

// Configure adds the provider configured client to the data source
func (d *costEstimateDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*SousChefClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *SousChefClient, got: %T", req.ProviderData),
                )
                return
        }</span>

        <span class="cov8" title="1">d.client = client</span>
}

// Read refreshes the Terraform state with the latest data
func (d *costEstimateDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var config costEstimateDataSourceModel
        diags := req.Config.Get(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cookbookPath := config.CookbookPath.ValueString()

        // Default rates
        developerRate := 150.0
        if !config.DeveloperHourlyRate.IsNull() </span><span class="cov8" title="1">{
                developerRate = config.DeveloperHourlyRate.ValueFloat64()
        }</span>

        <span class="cov8" title="1">infraCost := 500.0
        if !config.InfrastructureCost.IsNull() </span><span class="cov8" title="1">{
                infraCost = config.InfrastructureCost.ValueFloat64()
        }</span>

        // Get assessment data using existing assess-cookbook command
        // This would normally call the CLI, but for cost estimation we'll calculate based on patterns

        // For now, we'll do a simple analysis similar to assessment
        // In production, this would call: souschef assess-cookbook --cookbook-path &lt;path&gt; --format json

        // Simplified analysis (in production this would parse actual cookbook)
        <span class="cov8" title="1">recipeCount := int64(1)    // Placeholder
        resourceCount := int64(10) // Placeholder
        complexity := "Medium"

        var estimatedHours float64
        switch complexity </span>{
        case "Low":<span class="cov0" title="0">
                estimatedHours = float64(resourceCount) * 0.5</span>
        case "Medium":<span class="cov8" title="1">
                estimatedHours = float64(resourceCount) * 1.0</span>
        case "High":<span class="cov0" title="0">
                estimatedHours = float64(resourceCount) * 1.5</span>
        default:<span class="cov0" title="0">
                estimatedHours = float64(resourceCount) * 1.0</span>
        }

        // Calculate costs
        <span class="cov8" title="1">labourCost := estimatedHours * developerRate
        totalCost := labourCost + infraCost

        recommendations := fmt.Sprintf(
                "Cookbook requires approximately %.1f hours of migration effort. "+
                        "Estimated labour cost: $%.2f USD (at $%.2f/hour). "+
                        "Including infrastructure costs: $%.2f USD total. "+
                        "Complexity level: %s.",
                estimatedHours, labourCost, developerRate, totalCost, complexity,
        )

        // Set computed values
        config.ID = types.StringValue(cookbookPath)
        config.Complexity = types.StringValue(complexity)
        config.RecipeCount = types.Int64Value(recipeCount)
        config.ResourceCount = types.Int64Value(resourceCount)
        config.EstimatedHours = types.Float64Value(estimatedHours)
        config.EstimatedCostUSD = types.Float64Value(labourCost)
        config.DeveloperHourlyRate = types.Float64Value(developerRate)
        config.InfrastructureCost = types.Float64Value(infraCost)
        config.TotalProjectCostUSD = types.Float64Value(totalCost)
        config.Recommendations = types.StringValue(recommendations)

        diags = resp.State.Set(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package provider implements the SousChef Terraform provider
package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces
var (
        _ provider.Provider = &amp;SousChefProvider{}
)

// SousChefProvider defines the provider implementation.
type SousChefProvider struct {
        // version is set to the provider version on release
        version string
}

// SousChefProviderModel describes the provider data model.
type SousChefProviderModel struct {
        SousChefPath types.String `tfsdk:"souschef_path"`
}

// New is a helper function to simplify provider server setup.
func New(version string) func() provider.Provider <span class="cov8" title="1">{
        return func() provider.Provider </span><span class="cov8" title="1">{
                return &amp;SousChefProvider{
                        version: version,
                }
        }</span>
}

// Metadata returns the provider type name.
func (p *SousChefProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = "souschef"
        resp.Version = p.version
}</span>

// Schema defines the provider-level schema for configuration data.
func (p *SousChefProvider) Schema(_ context.Context, _ provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                Description: "Terraform provider for managing Chef to Ansible migrations using SousChef.",
                Attributes: map[string]schema.Attribute{
                        "souschef_path": schema.StringAttribute{
                                Description: "Path to the SousChef CLI executable. Defaults to 'souschef' in PATH.",
                                Optional:    true,
                        },
                },
        }
}</span>

// Configure prepares a SousChef API client for data sources and resources.
func (p *SousChefProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov8" title="1">{
        var config SousChefProviderModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;config)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Configuration values are now available via config
        <span class="cov8" title="1">if config.SousChefPath.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("souschef_path"),
                        "Unknown SousChef Path",
                        "The provider cannot create the SousChef client as there is an unknown configuration value for the SousChef path.",
                )
        }</span>

        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Default values
        <span class="cov8" title="1">sousChefPath := "souschef"
        if !config.SousChefPath.IsNull() </span><span class="cov8" title="1">{
                sousChefPath = config.SousChefPath.ValueString()
        }</span>

        // Create client data that resources can use
        <span class="cov8" title="1">client := &amp;SousChefClient{
                Path: sousChefPath,
        }

        resp.DataSourceData = client
        resp.ResourceData = client</span>
}

// SousChefClient is a simple client that wraps CLI calls
type SousChefClient struct {
        Path string
}

// DataSources defines the data sources implemented in the provider.
func (p *SousChefProvider) DataSources(_ context.Context) []func() datasource.DataSource <span class="cov8" title="1">{
        return []func() datasource.DataSource{
                NewAssessmentDataSource,
                NewCostEstimateDataSource,
        }
}</span>

// Resources defines the resources implemented in the provider.
func (p *SousChefProvider) Resources(_ context.Context) []func() resource.Resource <span class="cov8" title="1">{
        return []func() resource.Resource{
                NewMigrationResource,
                NewBatchMigrationResource,
                NewHabitatMigrationResource,
                NewInSpecMigrationResource,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package provider implements the SousChef Terraform provider resources
package provider

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

const errorReadingBatchPlaybook = "Error reading playbook"

// Ensure the implementation satisfies the expected interfaces
var (
        _ resource.Resource                = &amp;batchMigrationResource{}
        _ resource.ResourceWithImportState = &amp;batchMigrationResource{}
)

// NewBatchMigrationResource creates a new batch migration resource
func NewBatchMigrationResource() resource.Resource <span class="cov8" title="1">{
        return &amp;batchMigrationResource{}
}</span>

// batchMigrationResource is the resource implementation
type batchMigrationResource struct {
        client *SousChefClient
}

// batchMigrationResourceModel describes the resource data model
type batchMigrationResourceModel struct {
        ID            types.String   `tfsdk:"id"`
        CookbookPath  types.String   `tfsdk:"cookbook_path"`
        OutputPath    types.String   `tfsdk:"output_path"`
        RecipeNames   []types.String `tfsdk:"recipe_names"`
        CookbookName  types.String   `tfsdk:"cookbook_name"`
        PlaybookCount types.Int64    `tfsdk:"playbook_count"`
        Playbooks     types.Map      `tfsdk:"playbooks"`
}

// Metadata returns the resource type name
func (r *batchMigrationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_batch_migration"
}</span>

// Schema defines the schema for the resource
func (r *batchMigrationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages batch migration of multiple Chef recipes to Ansible playbooks from a single cookbook.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Unique identifier for the batch migration",
                        },
                        "cookbook_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the Chef cookbook directory",
                        },
                        "output_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Directory where Ansible playbooks will be written",
                        },
                        "recipe_names": schema.ListAttribute{
                                Required:            true,
                                ElementType:         types.StringType,
                                MarkdownDescription: "List of recipe names to convert",
                        },
                        "cookbook_name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Name of the cookbook",
                        },
                        "playbook_count": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "Number of playbooks generated",
                        },
                        "playbooks": schema.MapAttribute{
                                Computed:            true,
                                ElementType:         types.StringType,
                                MarkdownDescription: "Map of recipe names to playbook content",
                        },
                },
        }
}</span>

// Configure adds the provider configured client to the resource
func (r *batchMigrationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*SousChefClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *SousChefClient, got: %T", req.ProviderData),
                )
                return
        }</span>

        <span class="cov8" title="1">r.client = client</span>
}

// Create creates the resource and sets the initial Terraform state
func (r *batchMigrationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        var plan batchMigrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cookbookPath := plan.CookbookPath.ValueString()
        outputPath := plan.OutputPath.ValueString()
        recipeNames := make([]string, len(plan.RecipeNames))
        for i, name := range plan.RecipeNames </span><span class="cov8" title="1">{
                recipeNames[i] = name.ValueString()
        }</span>

        // Create output directory
        <span class="cov8" title="1">if err := os.MkdirAll(outputPath, 0755); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating output directory",
                        fmt.Sprintf("Could not create directory %s: %s", outputPath, err),
                )
                return
        }</span>

        // Convert each recipe
        <span class="cov8" title="1">playbooks := make(map[string]string)
        for _, recipeName := range recipeNames </span><span class="cov8" title="1">{
                // Call souschef CLI to convert recipe
                cmd := exec.CommandContext(ctx, r.client.Path, "convert-recipe",
                        "--cookbook-path", cookbookPath,
                        "--recipe-name", recipeName,
                        "--output-path", outputPath)

                output, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error converting recipe",
                                fmt.Sprintf("Could not convert recipe %s: %s\nOutput: %s", recipeName, err, string(output)),
                        )
                        return
                }</span>

                // Read generated playbook
                <span class="cov8" title="1">playbookPath := filepath.Join(outputPath, recipeName+".yml")
                content, err := os.ReadFile(playbookPath)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                errorReadingBatchPlaybook,
                                fmt.Sprintf("Could not read generated playbook %s: %s", recipeName, err),
                        )
                        return
                }</span>

                <span class="cov8" title="1">playbooks[recipeName] = string(content)</span>
        }

        // Extract cookbook name from path
        <span class="cov8" title="1">cookbookName := filepath.Base(cookbookPath)

        // Convert playbooks map to types.Map
        playbooksMap, mapDiags := types.MapValueFrom(ctx, types.StringType, playbooks)
        resp.Diagnostics.Append(mapDiags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Set state
        <span class="cov8" title="1">plan.ID = types.StringValue(fmt.Sprintf("%s-batch", cookbookName))
        plan.CookbookName = types.StringValue(cookbookName)
        plan.PlaybookCount = types.Int64Value(int64(len(playbooks)))
        plan.Playbooks = playbooksMap

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Read refreshes the Terraform state with the latest data
func (r *batchMigrationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        var state batchMigrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">outputPath := state.OutputPath.ValueString()
        recipeNames := make([]string, len(state.RecipeNames))
        for i, name := range state.RecipeNames </span><span class="cov8" title="1">{
                recipeNames[i] = name.ValueString()
        }</span>

        // Check if any playbook exists
        <span class="cov8" title="1">anyExists := false
        playbooks := make(map[string]string)
        for _, recipeName := range recipeNames </span><span class="cov8" title="1">{
                playbookPath := filepath.Join(outputPath, recipeName+".yml")
                if _, err := os.Stat(playbookPath); err == nil </span><span class="cov8" title="1">{
                        anyExists = true
                        content, err := os.ReadFile(playbookPath)
                        if err != nil </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddError(
                                        errorReadingBatchPlaybook,
                                        fmt.Sprintf("Could not read playbook %s: %s", recipeName, err),
                                )
                                return
                        }</span>
                        <span class="cov8" title="1">playbooks[recipeName] = string(content)</span>
                }
        }

        <span class="cov8" title="1">if !anyExists </span><span class="cov0" title="0">{
                resp.State.RemoveResource(ctx)
                return
        }</span>

        // Update state with current content
        <span class="cov8" title="1">playbooksMap, mapDiags := types.MapValueFrom(ctx, types.StringType, playbooks)
        resp.Diagnostics.Append(mapDiags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">state.Playbooks = playbooksMap
        state.PlaybookCount = types.Int64Value(int64(len(playbooks)))

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)</span>
}

// Update updates the resource and sets the updated Terraform state on success
func (r *batchMigrationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        var plan batchMigrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get current state to preserve ID and cookbook_name
        <span class="cov8" title="1">var state batchMigrationResourceModel
        diags = req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Re-run conversion for all recipes
        <span class="cov8" title="1">cookbookPath := plan.CookbookPath.ValueString()
        outputPath := plan.OutputPath.ValueString()
        recipeNames := make([]string, len(plan.RecipeNames))
        for i, name := range plan.RecipeNames </span><span class="cov8" title="1">{
                recipeNames[i] = name.ValueString()
        }</span>

        // Extract cookbook name from path
        <span class="cov8" title="1">cookbookName := filepath.Base(cookbookPath)

        playbooks := make(map[string]string)
        for _, recipeName := range recipeNames </span><span class="cov8" title="1">{
                cmd := exec.CommandContext(ctx, r.client.Path, "convert-recipe",
                        "--cookbook-path", cookbookPath,
                        "--recipe-name", recipeName,
                        "--output-path", outputPath)

                output, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error converting recipe",
                                fmt.Sprintf("Could not convert recipe %s: %s\nOutput: %s", recipeName, err, string(output)),
                        )
                        return
                }</span>

                <span class="cov8" title="1">playbookPath := filepath.Join(outputPath, recipeName+".yml")
                content, err := os.ReadFile(playbookPath)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                errorReadingBatchPlaybook,
                                fmt.Sprintf("Could not read updated playbook %s: %s", recipeName, err),
                        )
                        return
                }</span>

                <span class="cov8" title="1">playbooks[recipeName] = string(content)</span>
        }

        <span class="cov8" title="1">playbooksMap, mapDiags := types.MapValueFrom(ctx, types.StringType, playbooks)
        resp.Diagnostics.Append(mapDiags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">plan.Playbooks = playbooksMap
        plan.PlaybookCount = types.Int64Value(int64(len(playbooks)))
        plan.CookbookName = types.StringValue(cookbookName)
        plan.ID = types.StringValue(fmt.Sprintf("%s-batch", cookbookName))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Delete deletes the resource and removes the Terraform state on success
func (r *batchMigrationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        var state batchMigrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">outputPath := state.OutputPath.ValueString()
        recipeNames := make([]string, len(state.RecipeNames))
        for i, name := range state.RecipeNames </span><span class="cov8" title="1">{
                recipeNames[i] = name.ValueString()
        }</span>

        // Delete generated playbooks
        <span class="cov8" title="1">for _, recipeName := range recipeNames </span><span class="cov8" title="1">{
                playbookPath := filepath.Join(outputPath, recipeName+".yml")
                if err := os.Remove(playbookPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddWarning(
                                "Error deleting playbook",
                                fmt.Sprintf("Could not delete playbook %s: %s", recipeName, err),
                        )
                }</span>
        }
}

// ImportState imports an existing resource into Terraform
func (r *batchMigrationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        // Import ID format: cookbook_path|output_path|recipe1,recipe2,recipe3
        parts := strings.Split(req.ID, "|")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Invalid import ID",
                        "Import ID must be in format: cookbook_path|output_path|recipe1,recipe2,recipe3",
                )
                return
        }</span>

        <span class="cov8" title="1">cookbookPath := parts[0]
        outputPath := parts[1]
        recipeNamesStr := parts[2]

        // Validate that the cookbook directory exists
        if _, err := os.Stat(cookbookPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Cookbook not found",
                        fmt.Sprintf("Cookbook path does not exist: %s", cookbookPath),
                )
                return
        }</span>

        // Parse recipe names
        <span class="cov8" title="1">recipeNames := strings.Split(recipeNamesStr, ",")
        if len(recipeNames) == 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Invalid import ID",
                        "At least one recipe name must be specified",
                )
                return
        }</span>

        // Read all playbooks and validate they exist
        <span class="cov8" title="1">playbooks := make(map[string]string)
        for _, recipeName := range recipeNames </span><span class="cov8" title="1">{
                playbookPath := filepath.Join(outputPath, recipeName+".yml")
                if _, err := os.Stat(playbookPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        resp.Diagnostics.AddError(
                                "Playbook not found",
                                fmt.Sprintf("Playbook does not exist: %s", playbookPath),
                        )
                        return
                }</span>

                <span class="cov8" title="1">content, err := os.ReadFile(playbookPath)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                errorReadingBatchPlaybook,
                                fmt.Sprintf("Could not read playbook %s: %s", recipeName, err),
                        )
                        return
                }</span>

                <span class="cov8" title="1">playbooks[recipeName] = string(content)</span>
        }

        // Extract cookbook name from path
        <span class="cov8" title="1">cookbookName := filepath.Base(cookbookPath)

        // Convert recipe names to types
        recipeNamesTypes := make([]types.String, len(recipeNames))
        for i, name := range recipeNames </span><span class="cov8" title="1">{
                recipeNamesTypes[i] = types.StringValue(name)
        }</span>

        // Convert playbooks map to types.Map
        <span class="cov8" title="1">playbooksMap, mapDiags := types.MapValueFrom(ctx, types.StringType, playbooks)
        resp.Diagnostics.Append(mapDiags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Set state
        <span class="cov8" title="1">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("cookbook_path"), cookbookPath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("output_path"), outputPath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("recipe_names"), recipeNamesTypes)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("cookbook_name"), cookbookName)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("playbook_count"), int64(len(playbooks)))...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("playbooks"), playbooksMap)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), fmt.Sprintf("%s-batch", cookbookName))...)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package provider implements the SousChef Terraform provider resources
package provider

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces
var (
        _ resource.Resource                = &amp;habitatMigrationResource{}
        _ resource.ResourceWithImportState = &amp;habitatMigrationResource{}
)

// NewHabitatMigrationResource creates a new Habitat migration resource
func NewHabitatMigrationResource() resource.Resource <span class="cov8" title="1">{
        return &amp;habitatMigrationResource{}
}</span>

// habitatMigrationResource is the resource implementation
type habitatMigrationResource struct {
        client *SousChefClient
}

// habitatMigrationResourceModel describes the resource data model
type habitatMigrationResourceModel struct {
        ID                types.String `tfsdk:"id"`
        PlanPath          types.String `tfsdk:"plan_path"`
        OutputPath        types.String `tfsdk:"output_path"`
        BaseImage         types.String `tfsdk:"base_image"`
        PackageName       types.String `tfsdk:"package_name"`
        DockerfileContent types.String `tfsdk:"dockerfile_content"`
}

const (
        errReadingDockerfile = "Error reading Dockerfile"
        defaultBaseImage     = "ubuntu:latest"
        habitatIDFormat      = "habitat-%s"
)

// Metadata returns the resource type name
func (r *habitatMigrationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_habitat_migration"
}</span>

// Schema defines the schema for the resource
func (r *habitatMigrationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages conversion of Chef Habitat plans to Dockerfiles.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Unique identifier for the Habitat migration",
                        },
                        "plan_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the Habitat plan.sh file",
                        },
                        "output_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Directory where Dockerfile will be written",
                        },
                        "base_image": schema.StringAttribute{
                                Optional:            true,
                                Computed:            true,
                                MarkdownDescription: "Base Docker image to use (default: ubuntu:latest)",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "package_name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Name of the Habitat package",
                        },
                        "dockerfile_content": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Generated Dockerfile content",
                        },
                },
        }
}</span>

// Configure adds the provider configured client to the resource
func (r *habitatMigrationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*SousChefClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *SousChefClient, got: %T", req.ProviderData),
                )
                return
        }</span>

        <span class="cov8" title="1">r.client = client</span>
}

// Create creates the resource and sets the initial Terraform state
func (r *habitatMigrationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        var plan habitatMigrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">planPath := plan.PlanPath.ValueString()
        outputPath := plan.OutputPath.ValueString()
        baseImage := defaultBaseImage
        if !plan.BaseImage.IsNull() &amp;&amp; plan.BaseImage.ValueString() != "" </span><span class="cov8" title="1">{
                baseImage = plan.BaseImage.ValueString()
        }</span>

        // Create output directory
        <span class="cov8" title="1">if err := os.MkdirAll(outputPath, 0755); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating output directory",
                        fmt.Sprintf("Could not create directory %s: %s", outputPath, err),
                )
                return
        }</span>

        // Call souschef CLI to convert Habitat plan
        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, r.client.Path, "convert-habitat",
                "--plan-path", planPath,
                "--output-path", outputPath,
                "--base-image", baseImage)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error converting Habitat plan",
                        fmt.Sprintf("Could not convert plan: %s\nOutput: %s", err, string(output)),
                )
                return
        }</span>

        // Read generated Dockerfile
        <span class="cov8" title="1">dockerfilePath := filepath.Join(outputPath, "Dockerfile")
        content, err := os.ReadFile(dockerfilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingDockerfile,
                        fmt.Sprintf("Could not read generated Dockerfile: %s", err),
                )
                return
        }</span>

        // Extract package name from plan path
        <span class="cov8" title="1">packageName := filepath.Base(filepath.Dir(planPath))

        // Set state
        plan.ID = types.StringValue(fmt.Sprintf(habitatIDFormat, packageName))
        plan.BaseImage = types.StringValue(baseImage)
        plan.PackageName = types.StringValue(packageName)
        plan.DockerfileContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Read refreshes the Terraform state with the latest data
func (r *habitatMigrationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        var state habitatMigrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">dockerfilePath := filepath.Join(state.OutputPath.ValueString(), "Dockerfile")

        if _, err := os.Stat(dockerfilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov8" title="1">content, err := os.ReadFile(dockerfilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingDockerfile,
                        fmt.Sprintf("Could not read Dockerfile: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">state.DockerfileContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)</span>
}

// Update updates the resource and sets the updated Terraform state on success
func (r *habitatMigrationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        var plan habitatMigrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">planPath := plan.PlanPath.ValueString()
        outputPath := plan.OutputPath.ValueString()
        baseImage := defaultBaseImage
        if !plan.BaseImage.IsNull() &amp;&amp; plan.BaseImage.ValueString() != "" </span><span class="cov8" title="1">{
                baseImage = plan.BaseImage.ValueString()
        }</span>

        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, r.client.Path, "convert-habitat",
                "--plan-path", planPath,
                "--output-path", outputPath,
                "--base-image", baseImage)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error converting Habitat plan",
                        fmt.Sprintf("Could not convert plan: %s\nOutput: %s", err, string(output)),
                )
                return
        }</span>

        <span class="cov8" title="1">dockerfilePath := filepath.Join(outputPath, "Dockerfile")
        content, err := os.ReadFile(dockerfilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingDockerfile,
                        fmt.Sprintf("Could not read updated Dockerfile: %s", err),
                )
                return
        }</span>

        // Extract package name from plan path
        <span class="cov8" title="1">packageName := filepath.Base(filepath.Dir(planPath))

        // Set state
        plan.ID = types.StringValue(fmt.Sprintf(habitatIDFormat, packageName))
        plan.BaseImage = types.StringValue(baseImage)
        plan.PackageName = types.StringValue(packageName)
        plan.DockerfileContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Delete deletes the resource and removes the Terraform state on success
func (r *habitatMigrationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        var state habitatMigrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">dockerfilePath := filepath.Join(state.OutputPath.ValueString(), "Dockerfile")
        if err := os.Remove(dockerfilePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Error deleting Dockerfile",
                        fmt.Sprintf("Could not delete Dockerfile: %s", err),
                )
        }</span>
}

// ImportState imports an existing resource into Terraform
func (r *habitatMigrationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        // Import ID format: plan_path|output_path|base_image (base_image is optional)
        parts := strings.Split(req.ID, "|")
        if len(parts) &lt; 2 || len(parts) &gt; 3 </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Invalid import ID",
                        "Import ID must be in format: plan_path|output_path or plan_path|output_path|base_image",
                )
                return
        }</span>

        <span class="cov8" title="1">planPath := parts[0]
        outputPath := parts[1]
        baseImage := defaultBaseImage // default
        if len(parts) == 3 &amp;&amp; parts[2] != "" </span><span class="cov8" title="1">{
                baseImage = parts[2]
        }</span>

        // Validate that the plan file exists
        <span class="cov8" title="1">if _, err := os.Stat(planPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Plan file not found",
                        fmt.Sprintf("Plan file does not exist: %s", planPath),
                )
                return
        }</span>

        // Check if Dockerfile exists
        <span class="cov8" title="1">dockerfilePath := filepath.Join(outputPath, "Dockerfile")
        if _, err := os.Stat(dockerfilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Dockerfile not found",
                        fmt.Sprintf("Dockerfile does not exist: %s", dockerfilePath),
                )
                return
        }</span>

        // Read Dockerfile content
        <span class="cov8" title="1">content, err := os.ReadFile(dockerfilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingDockerfile,
                        fmt.Sprintf("Could not read Dockerfile: %s", err),
                )
                return
        }</span>

        // Extract package name from plan path (parent directory name)
        <span class="cov8" title="1">packageName := filepath.Base(filepath.Dir(planPath))

        // Set state
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("plan_path"), planPath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("output_path"), outputPath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("base_image"), baseImage)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("package_name"), packageName)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("dockerfile_content"), string(content))...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), fmt.Sprintf(habitatIDFormat, packageName))...)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package provider implements the SousChef Terraform provider resources
package provider

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces
var (
        _ resource.Resource                = &amp;inspecMigrationResource{}
        _ resource.ResourceWithImportState = &amp;inspecMigrationResource{}
)

// NewInSpecMigrationResource creates a new InSpec migration resource
func NewInSpecMigrationResource() resource.Resource <span class="cov8" title="1">{
        return &amp;inspecMigrationResource{}
}</span>

// inspecMigrationResource is the resource implementation
type inspecMigrationResource struct {
        client *SousChefClient
}

// inspecMigrationResourceModel describes the resource data model
type inspecMigrationResourceModel struct {
        ID           types.String `tfsdk:"id"`
        ProfilePath  types.String `tfsdk:"profile_path"`
        OutputPath   types.String `tfsdk:"output_path"`
        OutputFormat types.String `tfsdk:"output_format"`
        ProfileName  types.String `tfsdk:"profile_name"`
        TestContent  types.String `tfsdk:"test_content"`
}

const (
        testinfraFilename   = "test_spec.py"
        serverspecFilename  = "spec_helper.rb"
        gossFilename        = "goss.yaml"
        ansibleFilename     = "assert.yml"
        defaultTestFilename = "test.txt"
        errReadingTestFile  = "Error reading test file"
        inspecIDFormat      = "inspec-%s-%s"
)

// Metadata returns the resource type name
func (r *inspecMigrationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_inspec_migration"
}</span>

// Schema defines the schema for the resource
func (r *inspecMigrationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                MarkdownDescription: "Manages conversion of Chef InSpec profiles to various test frameworks.",

                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Unique identifier for the InSpec migration",
                        },
                        "profile_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Path to the InSpec profile directory",
                        },
                        "output_path": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Directory where converted tests will be written",
                        },
                        "output_format": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Output test framework format (testinfra, serverspec, goss, or ansible)",
                        },
                        "profile_name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Name of the InSpec profile",
                        },
                        "test_content": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Generated test content",
                        },
                },
        }
}</span>

// Configure adds the provider configured client to the resource
func (r *inspecMigrationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*SousChefClient)
        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *SousChefClient, got: %T", req.ProviderData),
                )
                return
        }</span>

        <span class="cov8" title="1">r.client = client</span>
}

// Create creates the resource and sets the initial Terraform state
func (r *inspecMigrationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        var plan inspecMigrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">profilePath := plan.ProfilePath.ValueString()
        outputPath := plan.OutputPath.ValueString()
        outputFormat := plan.OutputFormat.ValueString()

        // Create output directory
        if err := os.MkdirAll(outputPath, 0755); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating output directory",
                        fmt.Sprintf("Could not create directory %s: %s", outputPath, err),
                )
                return
        }</span>

        // Call souschef CLI to convert InSpec profile
        <span class="cov8" title="1">cmd := exec.CommandContext(ctx, r.client.Path, "convert-inspec",
                "--profile-path", profilePath,
                "--output-path", outputPath,
                "--format", outputFormat)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error converting InSpec profile",
                        fmt.Sprintf("Could not convert profile: %s\nOutput: %s", err, string(output)),
                )
                return
        }</span>

        // Determine output file extension based on format
        <span class="cov8" title="1">var testFilename string
        switch outputFormat </span>{
        case "testinfra":<span class="cov8" title="1">
                testFilename = testinfraFilename</span>
        case "serverspec":<span class="cov8" title="1">
                testFilename = serverspecFilename</span>
        case "goss":<span class="cov8" title="1">
                testFilename = gossFilename</span>
        case "ansible":<span class="cov8" title="1">
                testFilename = ansibleFilename</span>
        default:<span class="cov0" title="0">
                testFilename = defaultTestFilename</span>
        }

        // Read generated test file
        <span class="cov8" title="1">testFilePath := filepath.Join(outputPath, testFilename)
        content, err := os.ReadFile(testFilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingTestFile,
                        fmt.Sprintf("Could not read generated test file: %s", err),
                )
                return
        }</span>

        // Extract profile name from path
        <span class="cov8" title="1">profileName := filepath.Base(profilePath)

        // Set state
        plan.ID = types.StringValue(fmt.Sprintf(inspecIDFormat, profileName, outputFormat))
        plan.ProfileName = types.StringValue(profileName)
        plan.TestContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Read refreshes the Terraform state with the latest data
func (r *inspecMigrationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        var state inspecMigrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">outputPath := state.OutputPath.ValueString()
        outputFormat := state.OutputFormat.ValueString()

        var testFilename string
        switch outputFormat </span>{
        case "testinfra":<span class="cov8" title="1">
                testFilename = "test_spec.py"</span>
        case "serverspec":<span class="cov8" title="1">
                testFilename = "spec_helper.rb"</span>
        case "goss":<span class="cov8" title="1">
                testFilename = "goss.yaml"</span>
        case "ansible":<span class="cov8" title="1">
                testFilename = "assert.yml"</span>
        default:<span class="cov0" title="0">
                testFilename = "test.txt"</span>
        }

        <span class="cov8" title="1">testFilePath := filepath.Join(outputPath, testFilename)

        if _, err := os.Stat(testFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.State.RemoveResource(ctx)
                return
        }</span>

        <span class="cov8" title="1">content, err := os.ReadFile(testFilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingTestFile,
                        fmt.Sprintf("Could not read test file: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">state.TestContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)</span>
}

// Update updates the resource and sets the updated Terraform state on success
func (r *inspecMigrationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        var plan inspecMigrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">profilePath := plan.ProfilePath.ValueString()
        outputPath := plan.OutputPath.ValueString()
        outputFormat := plan.OutputFormat.ValueString()

        cmd := exec.CommandContext(ctx, r.client.Path, "convert-inspec",
                "--profile-path", profilePath,
                "--output-path", outputPath,
                "--format", outputFormat)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error converting InSpec profile",
                        fmt.Sprintf("Could not convert profile: %s\nOutput: %s", err, string(output)),
                )
                return
        }</span>

        <span class="cov8" title="1">var testFilename string
        switch outputFormat </span>{
        case "testinfra":<span class="cov8" title="1">
                testFilename = testinfraFilename</span>
        case "serverspec":<span class="cov8" title="1">
                testFilename = serverspecFilename</span>
        case "goss":<span class="cov8" title="1">
                testFilename = gossFilename</span>
        case "ansible":<span class="cov8" title="1">
                testFilename = ansibleFilename</span>
        default:<span class="cov0" title="0">
                testFilename = defaultTestFilename</span>
        }

        <span class="cov8" title="1">testFilePath := filepath.Join(outputPath, testFilename)
        content, err := os.ReadFile(testFilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingTestFile,
                        fmt.Sprintf("Could not read updated test file: %s", err),
                )
                return
        }</span>

        // Extract profile name from path
        <span class="cov8" title="1">profileName := filepath.Base(profilePath)

        // Set state
        plan.ID = types.StringValue(fmt.Sprintf(inspecIDFormat, profileName, outputFormat))
        plan.ProfileName = types.StringValue(profileName)
        plan.TestContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Delete deletes the resource and removes the Terraform state on success
func (r *inspecMigrationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        var state inspecMigrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">outputPath := state.OutputPath.ValueString()
        outputFormat := state.OutputFormat.ValueString()

        var testFilename string
        switch outputFormat </span>{
        case "testinfra":<span class="cov8" title="1">
                testFilename = testinfraFilename</span>
        case "serverspec":<span class="cov8" title="1">
                testFilename = serverspecFilename</span>
        case "goss":<span class="cov8" title="1">
                testFilename = gossFilename</span>
        case "ansible":<span class="cov8" title="1">
                testFilename = ansibleFilename</span>
        default:<span class="cov0" title="0">
                testFilename = defaultTestFilename</span>
        }

        <span class="cov8" title="1">testFilePath := filepath.Join(outputPath, testFilename)
        if err := os.Remove(testFilePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Error deleting test file",
                        fmt.Sprintf("Could not delete test file: %s", err),
                )
        }</span>
}

// ImportState imports an existing resource into Terraform
func (r *inspecMigrationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        // Import ID format: profile_path|output_path|output_format
        parts := strings.Split(req.ID, "|")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Invalid import ID",
                        "Import ID must be in format: profile_path|output_path|output_format",
                )
                return
        }</span>

        <span class="cov8" title="1">profilePath := parts[0]
        outputPath := parts[1]
        outputFormat := parts[2]

        // Validate that the profile directory exists
        if _, err := os.Stat(profilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Profile not found",
                        fmt.Sprintf("Profile path does not exist: %s", profilePath),
                )
                return
        }</span>

        // Determine test filename based on output format
        <span class="cov8" title="1">var testFilename string
        switch outputFormat </span>{
        case "testinfra":<span class="cov0" title="0">
                testFilename = testinfraFilename</span>
        case "serverspec":<span class="cov0" title="0">
                testFilename = serverspecFilename</span>
        case "goss":<span class="cov8" title="1">
                testFilename = gossFilename</span>
        case "ansible":<span class="cov0" title="0">
                testFilename = ansibleFilename</span>
        default:<span class="cov0" title="0">
                testFilename = defaultTestFilename</span>
        }

        // Check if test file exists
        <span class="cov8" title="1">testFilePath := filepath.Join(outputPath, testFilename)
        if _, err := os.Stat(testFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Test file not found",
                        fmt.Sprintf("Test file does not exist: %s", testFilePath),
                )
                return
        }</span>

        // Read test content
        <span class="cov8" title="1">content, err := os.ReadFile(testFilePath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errReadingTestFile,
                        fmt.Sprintf("Could not read test file: %s", err),
                )
                return
        }</span>

        // Extract profile name from path
        <span class="cov8" title="1">profileName := filepath.Base(profilePath)

        // Set state
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("profile_path"), profilePath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("output_path"), outputPath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("output_format"), outputFormat)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("profile_name"), profileName)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("test_content"), string(content))...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), fmt.Sprintf(inspecIDFormat, profileName, outputFormat))...)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package provider implements the SousChef Terraform provider resources
package provider

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

const errorReadingPlaybook = "Error reading playbook"

// Ensure the implementation satisfies the expected interfaces
var (
        _ resource.Resource                = &amp;migrationResource{}
        _ resource.ResourceWithConfigure   = &amp;migrationResource{}
        _ resource.ResourceWithImportState = &amp;migrationResource{}
)

// NewMigrationResource is a helper function to simplify the provider implementation.
func NewMigrationResource() resource.Resource <span class="cov8" title="1">{
        return &amp;migrationResource{}
}</span>

// migrationResource is the resource implementation.
type migrationResource struct {
        client *SousChefClient
}

// migrationResourceModel maps the resource schema data.
type migrationResourceModel struct {
        ID              types.String `tfsdk:"id"`
        CookbookPath    types.String `tfsdk:"cookbook_path"`
        OutputPath      types.String `tfsdk:"output_path"`
        CookbookName    types.String `tfsdk:"cookbook_name"`
        RecipeName      types.String `tfsdk:"recipe_name"`
        PlaybookContent types.String `tfsdk:"playbook_content"`
}

// Metadata returns the resource type name.
func (r *migrationResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_migration"
}</span>

// Schema defines the schema for the resource.
func (r *migrationResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                Description: "Manages a Chef cookbook to Ansible playbook migration.",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Description: "Unique identifier for the migration (cookbook-recipe).",
                                Computed:    true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "cookbook_path": schema.StringAttribute{
                                Description: "Path to the Chef cookbook directory.",
                                Required:    true,
                        },
                        "output_path": schema.StringAttribute{
                                Description: "Directory where Ansible playbook will be written.",
                                Required:    true,
                        },
                        "cookbook_name": schema.StringAttribute{
                                Description: "Name of the cookbook (parsed from metadata.rb).",
                                Computed:    true,
                        },
                        "recipe_name": schema.StringAttribute{
                                Description: "Name of the recipe to convert (default: 'default').",
                                Optional:    true,
                        },
                        "playbook_content": schema.StringAttribute{
                                Description: "Generated Ansible playbook YAML content.",
                                Computed:    true,
                        },
                },
        }
}</span>

// Configure adds the provider configured client to the resource.
func (r *migrationResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">client, ok := req.ProviderData.(*SousChefClient)

        if !ok </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *SousChefClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )
                return
        }</span>

        <span class="cov8" title="1">r.client = client</span>
}

// Create creates the resource and sets the initial Terraform state.
func (r *migrationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        var plan migrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get recipe name or default
        <span class="cov8" title="1">recipeName := "default"
        if !plan.RecipeName.IsNull() </span><span class="cov8" title="1">{
                recipeName = plan.RecipeName.ValueString()
        }</span>

        // Parse cookbook metadata
        <span class="cov8" title="1">cookbookPath := plan.CookbookPath.ValueString()
        outputPath := plan.OutputPath.ValueString()

        // Call souschef CLI to convert recipe
        cmd := exec.CommandContext(ctx, r.client.Path, "convert-recipe",
                "--cookbook-path", cookbookPath,
                "--recipe-name", recipeName,
                "--output-path", outputPath,
        )

        tflog.Debug(ctx, "Executing SousChef", map[string]interface{}{
                "command": cmd.String(),
        })

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Error converting recipe",
                        fmt.Sprintf("Could not convert recipe: %s\n%s", err, string(output)),
                )
                return
        }</span>

        // Read generated playbook
        <span class="cov8" title="1">playbookPath := filepath.Join(outputPath, recipeName+".yml")
        content, err := os.ReadFile(playbookPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errorReadingPlaybook,
                        fmt.Sprintf("Could not read generated playbook: %s", err),
                )
                return
        }</span>

        // Extract cookbook name from path
        <span class="cov8" title="1">cookbookName := filepath.Base(cookbookPath)

        // Set state
        plan.ID = types.StringValue(fmt.Sprintf("%s-%s", cookbookName, recipeName))
        plan.CookbookName = types.StringValue(cookbookName)
        plan.RecipeName = types.StringValue(recipeName)
        plan.PlaybookContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Read refreshes the Terraform state with the latest data.
func (r *migrationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        var state migrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Check if playbook still exists
        <span class="cov8" title="1">recipeName := state.RecipeName.ValueString()
        outputPath := state.OutputPath.ValueString()
        playbookPath := filepath.Join(outputPath, recipeName+".yml")

        if _, err := os.Stat(playbookPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                resp.State.RemoveResource(ctx)
                return
        }</span>

        // Read current content
        <span class="cov8" title="1">content, err := os.ReadFile(playbookPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errorReadingPlaybook,
                        fmt.Sprintf("Could not read playbook: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">state.PlaybookContent = types.StringValue(string(content))

        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)</span>
}

// Update updates the resource and sets the updated Terraform state on success.
func (r *migrationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        var plan migrationResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Re-run conversion
        <span class="cov8" title="1">recipeName := plan.RecipeName.ValueString()
        cookbookPath := plan.CookbookPath.ValueString()
        outputPath := plan.OutputPath.ValueString()

        // Extract cookbook name from path
        cookbookName := filepath.Base(cookbookPath)

        cmd := exec.CommandContext(ctx, r.client.Path, "convert-recipe",
                "--cookbook-path", cookbookPath,
                "--recipe-name", recipeName,
                "--output-path", outputPath,
        )

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Error updating migration",
                        fmt.Sprintf("Could not re-convert recipe: %s\n%s", err, string(output)),
                )
                return
        }</span>

        // Read updated playbook
        <span class="cov8" title="1">playbookPath := filepath.Join(outputPath, recipeName+".yml")
        content, err := os.ReadFile(playbookPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errorReadingPlaybook,
                        fmt.Sprintf("Could not read updated playbook: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">plan.PlaybookContent = types.StringValue(string(content))
        plan.CookbookName = types.StringValue(cookbookName)
        plan.ID = types.StringValue(fmt.Sprintf("%s-%s", cookbookName, recipeName))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)</span>
}

// Delete deletes the resource and removes the Terraform state on success.
func (r *migrationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        var state migrationResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove generated playbook
        <span class="cov8" title="1">recipeName := state.RecipeName.ValueString()
        outputPath := state.OutputPath.ValueString()
        playbookPath := filepath.Join(outputPath, recipeName+".yml")

        if err := os.Remove(playbookPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error deleting playbook",
                        fmt.Sprintf("Could not delete playbook: %s", err),
                )
                return
        }</span>

        <span class="cov8" title="1">tflog.Info(ctx, "Deleted migration resource", map[string]interface{}{
                "id": state.ID.ValueString(),
        })</span>
}

// ImportState imports an existing resource into Terraform
func (r *migrationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        // Import ID format: cookbook_path|output_path|recipe_name
        parts := strings.Split(req.ID, "|")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Invalid import ID",
                        "Import ID must be in format: cookbook_path|output_path|recipe_name",
                )
                return
        }</span>

        <span class="cov8" title="1">cookbookPath := parts[0]
        outputPath := parts[1]
        recipeName := parts[2]

        // Validate that the cookbook exists
        if _, err := os.Stat(cookbookPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Cookbook not found",
                        fmt.Sprintf("Cookbook path does not exist: %s", cookbookPath),
                )
                return
        }</span>

        // Check if playbook exists
        <span class="cov8" title="1">playbookPath := filepath.Join(outputPath, recipeName+".yml")
        if _, err := os.Stat(playbookPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Playbook not found",
                        fmt.Sprintf("Playbook does not exist: %s", playbookPath),
                )
                return
        }</span>

        // Read playbook content
        <span class="cov8" title="1">content, err := os.ReadFile(playbookPath)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        errorReadingPlaybook,
                        fmt.Sprintf("Could not read playbook: %s", err),
                )
                return
        }</span>

        // Extract cookbook name from path
        <span class="cov8" title="1">cookbookName := filepath.Base(cookbookPath)

        // Set state
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("cookbook_path"), cookbookPath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("output_path"), outputPath)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("recipe_name"), recipeName)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("cookbook_name"), cookbookName)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("playbook_content"), string(content))...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), fmt.Sprintf("%s-%s", cookbookName, recipeName))...)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
